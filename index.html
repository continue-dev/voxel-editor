<html>
  <head>
    <meta charset="utf-8" />
    <script src="three.min.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="dat.gui.min.js"></script>
    <script>
        var camera, scene, renderer;
        var plane;
        var mouse, raycaster, isShiftDown = false;

        var rollOverMesh, rollOverMaterial;
        var cubeGeo, cubeMaterial = [], materialIndex = 0;

        var objects = [];
        var contents = "";

        var text = {

            cubeColor0 : "#ff0000",
            cubeColor1 : "#00ff00",
            cubeColor2 : "#0000ff",
            cubeColor3 : "#ffff00",
            backgroundColor : "#23aeff",
            colorNum : function() {
                materialIndex += 1;
                if (materialIndex >= 4) {
                    materialIndex = 0;
                }
            }
        };

      // ページの読み込みを待つ
      window.addEventListener('load', init);
      function init() {
        // シーンを作成
        scene = new THREE.Scene();
        // カメラを作成
        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.set(0, 0, +1000);

        var rollOverGeo = new THREE.BoxBufferGeometry( 50, 50, 50 );
        rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
        rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
        scene.add( rollOverMesh );


        cubeGeo = new THREE.BoxBufferGeometry( 50, 50, 50 );
        cubeMaterial.push( new THREE.MeshLambertMaterial( { color: text.cubeColor0 } ) );
        cubeMaterial.push( new THREE.MeshLambertMaterial( { color: text.cubeColor1 } ) );
        cubeMaterial.push( new THREE.MeshLambertMaterial( { color: text.cubeColor2 } ) );
        cubeMaterial.push( new THREE.MeshLambertMaterial( { color: text.cubeColor3 } ) );


        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
                
        var gridHelper = new THREE.GridHelper( 1000, 20 );
        scene.add( gridHelper );

        var geometry = new THREE.PlaneBufferGeometry( 1000, 1000 );
        geometry.rotateX( - Math.PI / 2 );

        plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
        scene.add( plane );

        objects.push( plane );

        var ambientLight = new THREE.AmbientLight( 0x606060 );
        scene.add( ambientLight );

        var directionalLight = new THREE.DirectionalLight( 0xffffff );
        directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
        scene.add( directionalLight );

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        var controls = new THREE.OrbitControls( camera, renderer.domElement );

        gui = new dat.GUI();

        gui.addColor(text, 'cubeColor0');
        gui.addColor(text, 'cubeColor1');
        gui.addColor(text, 'cubeColor2');
        gui.addColor(text, 'cubeColor3');
        gui.addColor(text, 'backgroundColor');
        gui.add(text, 'colorNum' );

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        document.addEventListener( 'keydown', onDocumentKeyDown, false );
        document.addEventListener( 'keyup', onDocumentKeyUp, false );

        window.addEventListener( 'resize', onWindowResize, false );

        tick();
        // 毎フレーム時に実行されるループイベントです
        function tick() {
          controls.update();
          render();
//          renderer.render(scene, camera); // レンダリング
          requestAnimationFrame(tick);
        }
      }
      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }


      function onDocumentMouseMove( event ) {
        event.preventDefault();

        mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

        raycaster.setFromCamera( mouse, camera );

        var intersects = raycaster.intersectObjects( objects );

        if ( intersects.length > 0 ) {

            var intersect = intersects[ 0 ];
            rollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );
            rollOverMesh.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );

        }

        render();

        }

        function onDocumentMouseDown( event ) {

        event.preventDefault();

        mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

        raycaster.setFromCamera( mouse, camera );

        var intersects = raycaster.intersectObjects( objects );

        if ( intersects.length > 0 ) {

            var intersect = intersects[ 0 ];

            // delete cube

            if ( isShiftDown ) {

                if ( intersect.object !== plane ) {

                    scene.remove( intersect.object );

                    objects.splice( objects.indexOf( intersect.object ), 1 );

                }

                // create cube

            } else {

                var voxel = new THREE.Mesh( cubeGeo, cubeMaterial[materialIndex] );
                voxel.position.copy( intersect.point ).add( intersect.face.normal );
                voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
                scene.add( voxel );

                objects.push( voxel );

                contents += "{"
                    + "x:" + ((voxel.position.x + 25) / 50) + ","
                    + "y:" + ((voxel.position.y - 25) / 50) + ","
                    + "z:" + ((voxel.position.z + 25) / 50) + ","
                    + "r:" + voxel.material.color.r + ","
                    + "g:" + voxel.material.color.g + ","
                    + "b:" + voxel.material.color.b + ","
                    + "a:" + voxel.material.opacity + "},";
                    
                document.getElementById("content").textContent = contents;
                    

            }

            render();

        }

        }

        function onDocumentKeyDown( event ) {

        switch ( event.keyCode ) {

            case 16: isShiftDown = true; break;

        }

        }

        function onDocumentKeyUp( event ) {

        switch ( event.keyCode ) {

            case 16: isShiftDown = false; break;

        }

        }

        function render() {
            cubeMaterial[0].color.set(text.cubeColor0);
            cubeMaterial[1].color.set(text.cubeColor1);
            cubeMaterial[2].color.set(text.cubeColor2);
            cubeMaterial[3].color.set(text.cubeColor3);
            renderer.setClearColor(text.backgroundColor, 1.0);
            renderer.render( scene, camera );
        }
        function download() {
          console.log(contents);
          const blob = new Blob([ contents ], { "type" : "application/x-msdownload" });
        
          window.URL = window.URL || window.webkitURL;
          document.getElementById("download").setAttribute("href", window.URL.createObjectURL(blob));
          // document.getElementById("download").setAttribute("download", "tmp.txt");
        }

        function downLoadJson() {
          // var resultJson = JSON.stringify($scope.jsonObj);
          var downLoadLink = document.createElement("a");
          downLoadLink.download = "voxel.txt";
          downLoadLink.href = URL.createObjectURL(new Blob([contents], {type: "text.plain"}));
          downLoadLink.dataset.downloadurl = ["text/plain", downLoadLink.download, downLoadLink.href].join(":");
          downLoadLink.click();
      }
    </script>
  </head>
  <body>
    <div style="position: absolute;">
      <textarea id="content" cols="40" rows="5">voxelエディター</textarea>
      <button type="button" onclick="downLoadJson();">ダウンロード</button>
    </div>          
  </body>
</html>